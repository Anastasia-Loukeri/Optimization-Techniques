function [x_opt, f_opt, N] = fibonacci_search(f, a, b, l_target)

%
% Είσοδοι:
%   f:         Function handle της συνάρτησης.
%   a, b:      Όρια του αρχικού διαστήματος [a, b].
%   l_target:  Το επιθυμητό τελικό μήκος του διαστήματος (<= l_target).

%
% Έξοδοι:
%   x_opt:     Η εκτιμώμενη θέση του ελαχίστου.
%   f_opt:     Η τιμή της συνάρτησης στο x_opt.
%   N:         Συνολικός αριθμός υπολογισμών της συνάρτησης.

    L0 = b - a; % Αρχικό μήκος διαστήματος

    %  απαιτούμενοs αριθμό επαναλήψεων (K)
    % μικρότεροs αριθμόs Fibonacci F_K τέτοιο ώστε F_K >= L0 / l_target

    F = [1, 1]; % Ακολουθία Fibonacci (F_0, F_1)
    while F(end) < L0 / l_target
        F(end+1) = F(end) + F(end-1);

    end

    K = length(F) -2; % K είναι ο δείκτης της τελευταίας απαιτούμενης επανάληψης (F_K)

  

    % 2. Αρχικοποίηση (k=1)
    a_k = a;
    b_k = b;

    % Υπολογισμός των δύο αρχικών δοκιμαστικών σημείων (x_1, x_2)
    x1 = a_k + (F(K) / F(K+2)) * (b_k - a_k);
    x2 = a_k + (F(K+1) / F(K+2)) * (b_k - a_k);

    % Υπολογισμός των τιμών (2 υπολογισμοί)
    f_x1 = f(x1);
    f_x2 = f(x2);

    N = 2; % Αρχικοί υπολογισμοί

    % 3. Βρόχος Επανάληψης
    % i τρέχει από 2 έως Κ+1 αφού ξεκινήσαμε με K=1 (Κ επαναλήψεις)
    for i = 2:(K+1)

        % Τελευταίο βήμα: Χρησιμοποιείται το l_target
        if i == K+1 
            x2 = x1; % Το x2 γίνεται το x1 (όπως συνήθως)
            x1 = x1 - l_target; % x1 μετατοπίζεται ελάχιστα

            f_x2 = f_x1; % f(x2) γίνεται f(x1)
            f_x1 = f(x1); % Νέος υπολογισμός f(x1)

            N = N + 1; % +1 υπολογισμός
        else
            % Κανονικό βήμα Fibonacci
            % x_k+1 και f(x_k+1) γίνονται τα x_k και f(x_k) του επόμενου βήματος

            if f_x1 < f_x2 % Η ελάχιστη τιμή βρίσκεται στο [a_k, x_2]
                % Το νέο διάστημα είναι [a_k, x_2]
                b_k = x2;
                x2 = x1; % Το παλιό x1 γίνεται το νέο x2
                f_x2 = f_x1;

                % Υπολογισμός του νέου x1
                x1 = a_k + (F(K-i+1) / F(K-i+3)) * (b_k - a_k);
                f_x1 = f(x1); % +1 υπολογισμός
                N = N + 1;

            elseif f_x1 > f_x2 % Η ελάχιστη τιμή βρίσκεται στο [x_1, b_k]
                % Το νέο διάστημα είναι [x_1, b_k]
                a_k = x1;
                x1 = x2; % Το παλιό x2 γίνεται το νέο x1
                f_x1 = f_x2;

                % Υπολογισμός του νέου x2
                x2 = a_k + (F(K-i+2) / F(K-i+3)) * (b_k - a_k);
                f_x2 = f(x2); % +1 υπολογισμός
                N = N + 1;

            % else % f_x1 = f_x2 (Σπάνια περίπτωση)
            %     a_k = x1;
            %     b_k = x2;
            %     % Επαναλαμβάνεται το βήμα με νέο L_k, x1, x2.
            %     x1 = a_k + (F(K-i) / F(K-i+2)) * (b_k - a_k);
            %     x2 = a_k + (F(K-i+1) / F(K-i+2)) * (b_k - a_k);
            %     f_x1 = f(x1); 
            %     f_x2 = f(x2); 
            %     N = N + 2; % Εδώ χρειάζονται 2 υπολογισμοί
            end
        end
    end

    % 4. Τελική Εκτίμηση
    % Μετά την τελευταία επανάληψη, το ελάχιστο βρίσκεται στο [x1, x2] ή [a_k, b_k]
    if f_x1 < f_x2
        x_opt = (a_k + x2) / 2;
    else
        x_opt = (x1 + b_k) / 2;
    end

    f_opt = f(x_opt); % τελικός υπολογισμός για την f_opt
    

end

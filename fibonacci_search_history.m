function [a_hist, b_hist, k_hist] = fibonacci_search_history(f, a, b, l_target)

%
% Είσοδοι:
%   f:         Function handle της συνάρτησης.
%   a, b:      Όρια του αρχικού διαστήματος [a, b].
%   l_target:  Το επιθυμητό τελικό μήκος του διαστήματος (L_K <= l_target).
%   epsilon:   Μικρή σταθερά διαχωρισμού για το τελικό βήμα.
%
% Έξοδοι:
%   a_hist:    Ιστορικό των κάτω ορίων a_k.
%   b_hist:    Ιστορικό των άνω ορίων b_k.
%   k_hist:    Δείκτης επαναλήψεων k.

    L0 = b - a; % Αρχικό μήκος διαστήματος

    % 1. Βρες τον απαιτούμενο αριθμό επαναλήψεων (K)
    F = [1, 1]; 
    while F(end) < L0 / l_target
        F(end+1) = F(end) + F(end-1);
    end
    K = length(F) - 2; 
    
    if K < 2
        a_hist = a; b_hist = b; k_hist = 0;
        return;
    end
    
    % 2. Αρχικοποίηση (k=0)
    ak = a;
    bk = b;
    k = 2; 
    a_hist = ak;
    b_hist = bk;
    k_hist = k;
    
    % Υπολογισμός των δύο αρχικών δοκιμαστικών σημείων (k=0, αλλά K-1 επαναλήψεις)
    x1 = ak + (F(K) / F(K+2)) * (bk - ak);
    x2 = ak + (F(K+1) / F(K+2)) * (bk - ak);
    
    % Υπολογισμός των τιμών (f_x1, f_x2)
    f_x1 = f(x1);
    f_x2 = f(x2);
    
    % 3. Βρόχος Επανάληψης
    for i = 1:K % i τρέχει από 1 έως Κ
        
        % Αποθήκευση k+1
        k = k + 1; 

        % Τελευταίο βήμα: Χρησιμοποιείται το epsilon για να διαχωρίσει τα σημεία
        if i == K 
            x2_new = x1; % Το παλιό x1 γίνεται το νέο x2 (ή x1)
            x1_new = x2_new - l_target; % x1 μετατοπίζεται ελάχιστα (χρησιμοποιούμε x2_new ως βάση)
            
            % Ενημέρωση διαστήματος και αποθήκευση
            if f_x1 < f_x2 
                bk = x2;
            else
                ak = x1;
            end
            
            % Επειδή ο στόχος είναι η ιστορία, αρκεί η τελευταία ενημέρωση a, b
            
        else
            % Κανονικό βήμα Fibonacci
            
            if f_x1 < f_x2 % Η ελάχιστη τιμή βρίσκεται στο [ak, x2]
                bk = x2;
                x2 = x1;
                f_x2 = f_x1;
                
                % Υπολογισμός του νέου x1
                x1 = ak + (F(K-i+1) / F(K-i+3)) * (bk - ak);
                f_x1 = f(x1); 
                
            elseif f_x1 > f_x2 % Η ελάχιστη τιμή βρίσκεται στο [x1, bk]
                ak = x1;
                x1 = x2;
                f_x1 = f_x2;
                
                % Υπολογισμός του νέου x2
                x2 = ak + (F(K-i+2) / F(K-i+3)) * (bk - ak);
                f_x2 = f(x2);
                
            else % f_x1 = f_x2 (Σπάνια περίπτωση)
                % Εάν συμβεί αυτό, πρέπει να ενημερωθούν και τα δύο άκρα.
                % Ωστόσο, για την απλότητα του Fibonacci, θεωρούμε ότι η μονοκορυφότητα ισχύει.
                % Συνήθως, η εκτέλεση συνεχίζεται με ένα από τα δύο.
                bk = x2;
                x2 = x1;
                f_x2 = f_x1;
                x1 = ak + (F(K-i+1) / F(K-i+3)) * (bk - ak);
                f_x1 = f(x1); 
            end
        end
        
        % Αποθήκευση ιστορικού για την τρέχουσα επανάληψη
        a_hist(end+1) = ak;
        b_hist(end+1) = bk;
        k_hist(end+1) = k;
    end
end